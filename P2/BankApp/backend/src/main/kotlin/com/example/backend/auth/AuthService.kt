package com.example.backend.auth

import com.example.backend.dao.UserMapper
import com.example.backend.domain.Role
import com.example.backend.domain.Token
import com.example.backend.domain.User
import com.example.backend.domain.UserCreated
import com.example.backend.email.EmailService
import com.example.backend.email.EmailTemplateName
import com.example.backend.security.JwtService
import org.springframework.beans.factory.annotation.Value
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.math.BigDecimal
import java.security.SecureRandom
import java.time.LocalDateTime


@Service
class AuthService(
    private val passwordEncoder: PasswordEncoder,
    private val userMapper: UserMapper,
    private val emailService: EmailService,
    private val authenticationManager: AuthenticationManager,
    private val jwtService: JwtService,
    @Value("\${application.mailing.frontend.activation-url}")
    private val activationUrl: String
) {

    @Transactional
    fun registerUser(registrationRequest: RegistrationRequest): User {
        val newUser = UserCreated(
            firstName = registrationRequest.firstname,
            lastName = registrationRequest.lastname,
            email = registrationRequest.email,
            password = passwordEncoder.encode(registrationRequest.password),
        )
        val autoGeneratedId = userMapper.insertUser(newUser)
        val user = User(
            id = autoGeneratedId,
            firstName = newUser.firstName,
            lastName = newUser.lastName,
            email = newUser.email,
            password = newUser.password,
            balance = BigDecimal(0.000),
            enabled = false,
            roles = listOf(Role.USER),
        )
        sendValidationEmail(user)
        return user
    }
    fun authenticate(request: AuthRequest): AuthResponse {
        val auth = authenticationManager.authenticate(
            UsernamePasswordAuthenticationToken(
                request.email,
                request.password
            )
        )
        val claims = HashMap<String, Any>()
        val user = auth.principal as User
        claims["fullName"] = user.fullName()
        val jwtToken = jwtService.generateToken(claims, auth.principal as User)
        return AuthResponse(jwtToken)
    }
    private fun sendValidationEmail(user: User){
        val newToken = generateAndSaveActivationToken(user);

        emailService.sendEmail(
            user.email,
            user.fullName(),
            EmailTemplateName.ACTIVATE_ACCOUNT,
            activationUrl,
            newToken,
            "Account activation"
        );
    }

    @Transactional
    fun activateAccount(email: String) {
        val savedToken: Token = userMapper.getTokenByEmail(email) ?: throw RuntimeException("Invalid token")

        if (LocalDateTime.now().isAfter(savedToken.expiresAt)) {
            sendValidationEmail(user)
            throw RuntimeException("Activation token has expired. A new token has been send to the same email address")
        }
        userMapper.setTokenValidated(LocalDateTime.now(), user.email)
    }

    private fun generateAndSaveActivationToken(user: User): String {
        val generatedToken = generateActivationCode(6)
        val token = Token(
            token = generatedToken,
            createdAt = LocalDateTime.now(),
            expiresAt = LocalDateTime.now().plusMinutes(15),
            validatedAt = null
        )
        userMapper.addToken(token, user.email)
        return generatedToken
    }

    private fun generateActivationCode(length: Int): String {
        val characters = "0123456789"
        val codeBuilder = StringBuilder()
        val secureRandom = SecureRandom()
        for (i in 0..<length) {
            val randomIndex: Int = secureRandom.nextInt(characters.length)
            codeBuilder.append(characters[randomIndex])
        }
        return codeBuilder.toString()
    }
}